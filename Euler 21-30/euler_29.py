"""
Distinct Powers
------------------
Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5: 22=4, 23=8, 24=16, 
25=32
32=9, 33=27, 34=81, 35=243
42=16, 43=64, 44=256, 45=1024
52=25, 53=125, 54=625, 55=3125
When placed in numerical order without any repeats, the following sequence is made: 4, 
8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

Calculate the number of distinct terms in the sequence generated by a^b for 2 ≤ a ≤ n 
and 2 ≤ b ≤ n.
"""

import math

def distinct_powers(n):
    """ highest integer power of 2 ≤ n. """
    max_power = int(math.log2(n)) + 1
    duplicates_per_power = [0] * (max_power)
    num_of_powers = [0] * (max_power)
    total_duplicates = 0

    """ For each base, calculate the integers shared or duplicated between the powers 
    of that base. """
    for base in range(2, max_power):
        """ integers shared or duplicated between the powers of a particular base 
        within a certain range. """
        overlap = set()
        for exponent in range(1, base):
            """ interval between consecutive powers that are checked for overlap. """
            spacing = _lowest_common_multiple(exponent, base) // base # see Python-Project-Euler/Euler 1-50/Euler 1-10/euler_5.py
            multiple = 0
            while multiple <= exponent * n // base:
                overlap.add(multiple)
                multiple += spacing
        count = sum(1 for j in range(2, n + 1) if j in overlap)
        duplicates_per_power[base] = count

    sqrt_n = math.isqrt(n) + 1
    powers_not_to_repeat = set()
    """ iterates over exponents from 2 and calculate the powers of that base 
    until the power > n."""
    for base in range(2, sqrt_n):
        if base not in powers_not_to_repeat:
            exponent = 2
            while base ** exponent <= n:
                """ for each distinct power, increment the corresponding element in 
                num_of_powers. """
                num_of_powers[exponent] += 1
                if base ** exponent <= sqrt_n:
                    powers_not_to_repeat.add(base ** exponent)
                exponent += 1

    for exponent in range(2, max_power):
        total_duplicates += num_of_powers[exponent] * duplicates_per_power[exponent]

    """ number of distinct powers. """
    return (n - 1) * (n - 1) - total_duplicates

if __name__ == "__main__":
    print(distinct_powers(100))
