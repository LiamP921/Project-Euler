""" considering quadratics of the form: 'n^2 + an + b', where '|a|' < 1000, '|b|' <= 1000, and '|n|' = the absolute value of 'n', calculates the product of coefficients, 'a' and 'b', that produces the maximum number of primes for consecutive values of 'n', starting with 'n' = 0. """
from math import log
def sieveOfEratosthenes(n):
    m = 2 * n * int((log(n) + 1))
    primes = [True] * m
    p = 2
    count = 0

    while count < n:
        if primes[p]:
            count += 1
            for i in range(p * p, m, p):
                primes[i] = False
        p += 1

    primes_list = [i for i in range(2, m) if primes[i]]
    primes_list.sort()
    return primes_list

def countConsecutivePrimes(a, b):
    n = 0
    """ check no. of consecutive primes generated by increasing values of 'n'. Increment from 'n = 0' until the quadratic generates a non-prime. """
    while True:
        quadratic = n * n + a * n + b
        if quadratic not in primes:
            return n
        """ no. of consecutive primes. """
        n += 1

max_primes = 0
max_product = 0
""" presence checking via sets, as per #23, consisting of 'n' primes, as per #7. """
primes = set(sieveOfEratosthenes(1000))

""" generate all possible permutations of 'a' and 'b', as per #24. """
for a in range(-999, 1000):
    for b in range(-1000, 1000 + 1):
        if b not in primes:
            """ 'continue' skips current iteration, transferring control flow to the next.  """
            continue
        """ for each permutation, find the no. of consecutive primes generated by the corresponding quadratic. """
        num_primes = countConsecutivePrimes(a, b)
        if num_primes > max_primes:
            """ update both totals if number is > than former. """
            max_primes = num_primes
            max_product = a * b
          
print(max_product)
